Общая идея:
(1) - Делаем просто облачное хранилище без полной синхронизации (возможность синхронизации можно будет добавить позднее в ручном режиме)
(1) - Приложение будет работать на сокетах
(1) - Клиент и сервер общаются через сообщения ObjectOutputStream и ObjectInputStream
(1) - Логирование
(9) - Использовать защищённый протокол передачи данных
---------------------------------------------------
СЕРВЕР
---------------------------------------------------
Структура сервера:
(1) - Будет консольным, принимает запрос на подключение со стороны клиента, выдаёт ему личного Обработчика в отдельном потоке
(1) - Навигация по папке пользователя и отправка содержания папок самому клиенту, чтобы тот мог видеть, какие файлы у него хранятся на диске
(1) - Отправка выбранного клиентом файла ему обратно. Реализация передачи файлов
(1) - Механизм синхронизации при любом изменении файлов на сервере/добавления/удаления файлов
(8) - Возможность заливать несколько файлов в разных потоках, и, возможно, распараллелить для клиентов обработку команд
(8) - Расшаривание каталогов между пользователями (предоставление общего доступа). Список пользователей/Права
(*) - Можно использовать Thread pools
(*) - Должна иметь авторизацию и обрабатывать множественные сетевые подключения клиентов. Необходимо сделать диалоговое окно с кнопками "Старт/Стоп", кнопкой выбора папки для хранилища клиентских данных, полем выбора слушаемого порта и отображением текущих событий. Базу данных авторизации для простоты можно заполнять в SQLite. Серверная часть будет создавать у себя синхронизированные клиентские папки и файлы автоматически. Запрашивать, передавать и удалять файлы на основании дефолтной логики и получаемого списка от клиента

Авторизация и регистрация:
(1) - Авторизация на сервере будет по базе данных, в ней будет логин, пароль
(1) - Создание для него папки, если он только зарегистрировался
(5) - Хэширование пароля
(5) - Проверка на сложность пароля при регистрации

Хранение данных: 
(1) - Каждому пользователю при регистрации будет выделяться папка в определённом каталоге, которая будет привязана к логину каждого пользователя
(1) - Работать будем без вложенных папок только с корневыми файлами (для упрощения)
(2) - Решение конфликтов имен
(9) - Можно выделять какое-то определённое кол-во гигабайт на диске, которое пользователь сможет с течением времени увеличить. Для отслеживания объёма памяти, в Хэндлере каждого клиента будет переменная, равная размеру оставшейся памяти (лучше делать запись в БД). Каждый раз, загружая что-то на диск, мы будем вычислять размер загружаемого файла и вычитать его размер из оставшейся памяти. Если размер файла больше оставайся памяти, кидаем предупреждение
(9) - Когда клиент хочет залить файл, он отправляет серверу сообщение об этом (в сообщении отправляется crc32 или sha от файла), сервер поднимает еще один сокет, на который смотрит FileInputStream, отвечает клиенту сообщением вроде "Ок, давай" с номером порта, и начинает слушать файл на новом сокете. Как только файл получили, сверяется контрольная сумма, если все хорошо - файл сохраняется на диск, затем добавляется в табличку, затем клиенту отправляются сообщение, что всё ок. 
---------------------------------------------------
КЛИЕНТ
---------------------------------------------------
(1) - Пользовательский интерфейс на JavaFX
(1) - Пользователь должен указать папку куда будут падать файлы из облака
(1) - Структура GUI:
поле авторизации, кнопка, открывающая проводник для выбора файла, который нужно загрузить, несколько кнопок, отправляющих на сервер запросы:
• отправка файла
• деавторизация
• получение содержимого своего диска 
• удаление файла с диска
• скачивание файла
• создание новой директивы на диске
(9) - Так как у нас андроид факультет, предлагаю сделать сервер облачного хранилища с клиентом для андроид
(*) - Простой графический интерфейс без доп. диалоговых окон с возможностью задать ИП и порт сервера, изменить расположение локальной синхронизируемой папки, позволять менять простые настройки логики синхронизации (чекбоксы), уметь свернуться в системный трей без закрытия и иметь кнопку "Синхронизировать" (либо для большего упрощения реализации логики сделать раздельные кнопки "Отправить" и "Получить"). При нажатии на синхронизацию смотрим в папку, собираем данные по названиям и размерам файлов. Вычисляем хеши по единому с сервером алгоритму. Передачу, получение и удаление файлов производить на основе ответов сервера в соответствии с определенной дефолтной логикой и доп. настройками пользователя
5. В интерфейсе пользователь видит объем выделенной для него памяти, статус по заполненности памяти, список своих файлов и кнопки управления по загруке/скачиванию/удалению файлов. Не уверен, смогу ли реализовать функцию по типу ЯД "Поделиться"
---------------------------------------------------
ПОД ВОПРОСОМ
---------------------------------------------------
- Виртуальный каталог файлов клиента = БД для имён и настроек + файловое хранилище
- Можно ли притащить в проект Dagger 2? Очень хочу его освоить, но пока маловато практики
Если делать полную синхронизацию:
- Старый пользователь зашел с нового клиента - должны ли ему прилетать как-то файлы, которые он раньше заливал на сервер?
- Нужно ли на клиенте отслеживать изменение файлов, и перезаливать их, если, например, у них поменялась контрольная сумма?
2. В клиентской части реализовано логирование. Считаю достаточным четырех полей: имя, пароль и электронный адрес с номером телефона на случай восстановления пароля.
 Логирование производиться только на английском языке.
 Проверка надежности паролей проверяет введенный пароль на безопасность.
 Не уверен что смогу реализовать подтверждение электронного адреса. Но хотелось бы.
 Естесственно проверка имени пользователя на уникальность.
3. Для удобства реализована возможность корректировки персональных данных.
7. Сервер лимитирует количество подключенных пользователей в зависимости от объема памяти сервера поделенное на лимит для каждого пользователя.
11. Сервер защищен от внезапного разлогирования.
2. Историчность

Домашнее задание:
- Создать классы, отвечающие за сообщения: AbstractMessage, AuthMessage (данные авторизации клиента: логин/пароль), FileStructureMessage (структура файлов пользователя в облаке), FileDataMessage (обертка для передачи файла, имя файла и байтовый массив с содержимым), TextDataMessage (простое текстовое сообщение обернутое в объект)
- Серверную часть. С какой-то структурой каталогов для хранения данных (data/user1), с несколькими файлами. Сервер должен ожидать подключения клиента. Можно сразу распараллелить. Пока не делайте вложенных каталогов в папке клиента.
- Клиентская часть. Окно на JavaFX, в нем должно быть: кнопка подключения и выхода, ListView со списком файлов. При нажатии "подключиться" - подключаемся к серверу и запрашиваем список файлов, который потом отобразим в ListView. Подключаемся пока что под логином user1. Если сложно с ListView, то просто кидаем список в консоль, пока на занятии не вспомним про логику работы ListView.
- Получение файла с сервера в папку с клиентом.
- Загрузка файлов на сервер.
- База данных пользователей на сервере и система авторизации и регистрации.
- Решение конфликтов имен.
- Добавление в файловую структуру пользователей на сервере каталогов.